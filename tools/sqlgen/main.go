package main

import (
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

type SQLFile struct {
	Name      string
	Content   string
	ConstName string
}

type PackageConfig struct {
	PackageName string
	SQLFiles    []SQLFile
}

func readSQLFiles(dir string) ([]SQLFile, error) {
	var sqlFiles []SQLFile

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || !strings.HasSuffix(strings.ToLower(path), ".sql") {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("error reading %s: %v", path, err)
		}

		relPath, err := filepath.Rel(dir, path)
		if err != nil {
			relPath = filepath.Base(path)
		}

		nameWithoutExt := strings.TrimSuffix(relPath, filepath.Ext(relPath))
		constName := toCamelCase(nameWithoutExt)

		sqlFiles = append(sqlFiles, SQLFile{
			Name:      filepath.Base(path),
			Content:   string(content),
			ConstName: constName,
		})

		return nil
	})

	if err != nil && !os.IsNotExist(err) {
		return nil, err
	}

	return sqlFiles, nil
}

func toCamelCase(s string) string {
	reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	words := reg.Split(s, -1)

	var result strings.Builder
	for _, word := range words {
		if word == "" {
			continue
		}
		result.WriteString(strings.ToUpper(word[:1]))
		result.WriteString(strings.ToLower(word[1:]))
	}

	return result.String()
}

func generateSqlPackage(outputFile string, sqlFiles []SQLFile) error {
	config := PackageConfig{
		PackageName: "sql",
		SQLFiles:    sqlFiles,
	}

	const packageTemplate = `// Code generated by sqlgen; DO NOT EDIT.

package {{.PackageName}}

// SQL constants generated from SQL files
const (
{{- range .SQLFiles }}
	// {{.ConstName }} - generated from {{.Name }}
	{{.ConstName }} = ` + "`" + `{{.Content}}` + "`" + `
{{- end }}
)
`

	tmpl, err := template.New("package").Parse(packageTemplate)
	if err != nil {
		return fmt.Errorf("error parsing template: %v", err)
	}

	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating output file: %v", err)
	}
	defer file.Close()

	var buf strings.Builder
	if err := tmpl.Execute(&buf, config); err != nil {
		return fmt.Errorf("error executing template: %v", err)
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return fmt.Errorf("error formatting Go code: %v", err)
	}

	if _, err := file.Write(formatted); err != nil {
		return fmt.Errorf("error writing to file: %v", err)
	}

	return nil
}

func main() {
	fmt.Println("Generating SQL constants package...")

	args := os.Args
	if len(args) < 3 {
		fmt.Println("Specify input and output path for sqlgen line this:")
		fmt.Println("./sqlgen <input-path> <output-path>")
		os.Exit(1)
	}

	sqlDir := args[1]
	outputDir := args[2]
	outputFile := filepath.Join(outputDir, "sql.go")

	sqlFiles, err := readSQLFiles(sqlDir)
	if err != nil {
		fmt.Printf("Error reading SQL files: %v\n", err)
		os.Exit(1)
	}

	if len(sqlFiles) == 0 {
		fmt.Println("No SQL files found in", sqlDir)
		os.Exit(0)
	}

	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		fmt.Printf("Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	err = generateSqlPackage(outputFile, sqlFiles)
	if err != nil {
		fmt.Printf("Error generating package: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %d SQL constants in %s\n", len(sqlFiles), outputFile)
}
